{
	"compiler": {
		"version": "0.8.18+commit.87f61d96"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"name": "OnlyOwner",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "operator",
						"type": "address"
					}
				],
				"name": "OperatorNotAllowed",
				"type": "error"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"internalType": "address",
						"name": "newRegistry",
						"type": "address"
					}
				],
				"name": "OperatorFilterRegistryAddressUpdated",
				"type": "event"
			},
			{
				"inputs": [],
				"name": "operatorFilterRegistry",
				"outputs": [
					{
						"internalType": "contract IOperatorFilterRegistry",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "owner",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "newRegistry",
						"type": "address"
					}
				],
				"name": "updateOperatorFilterRegistryAddress",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"details": "This smart contract is meant to be inherited by token contracts so they can use the following:         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.",
			"errors": {
				"OnlyOwner()": [
					{
						"details": "Emitted when someone other than the owner is trying to call an only owner function."
					}
				],
				"OperatorNotAllowed(address)": [
					{
						"details": "Emitted when an operator is not allowed."
					}
				]
			},
			"kind": "dev",
			"methods": {
				"constructor": {
					"details": "The constructor that is called when the contract is being deployed."
				},
				"owner()": {
					"details": "Assume the contract has an owner, but leave specific Ownable implementation up to inheriting contract."
				}
			},
			"title": "UpdatableOperatorFilterer",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"updateOperatorFilterRegistryAddress(address)": {
					"notice": "Update the address that the contract will make OperatorFilter checks against. When set to the zero         address, checks will be bypassed. OnlyOwner."
				}
			},
			"notice": "Abstract contract whose constructor automatically registers and optionally subscribes to or copies another         registrant's entries in the OperatorFilterRegistry. This contract allows the Owner to update the         OperatorFilterRegistry address via updateOperatorFilterRegistryAddress, including to the zero address,         which will bypass registry checks.         Note that OpenSea will still disable creator earnings enforcement if filtered operators begin fulfilling orders         on-chain, eg, if the registry is revoked or bypassed.",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"contracts/MusubiCollection_flattened.sol": "UpdatableOperatorFilterer"
		},
		"evmVersion": "paris",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": true,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"contracts/MusubiCollection_flattened.sol": {
			"keccak256": "0x83942480ef3c8fa37282f440062c80427c7aba11793a274180ec26f148d9bc75",
			"license": "MIT",
			"urls": [
				"bzz-raw://6123a0048e823d6364f00132c0f499f4679352126e0642480a2cd9dde990482c",
				"dweb:/ipfs/QmbX9QUDvJKhq6LHJ6r52FXXVXTpM6qZufzEXHsnwoSGgF"
			]
		}
	},
	"version": 1
}